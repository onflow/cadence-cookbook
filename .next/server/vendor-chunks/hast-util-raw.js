"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-raw";
exports.ids = ["vendor-chunks/hast-util-raw"];
exports.modules = {

/***/ "(ssr)/./node_modules/hast-util-raw/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/hast-util-raw/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raw: () => (/* binding */ raw)\n/* harmony export */ });\n/* harmony import */ var parse5_lib_parser_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parse5/lib/parser/index.js */ \"(ssr)/./node_modules/parse5/lib/parser/index.js\");\n/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! unist-util-position */ \"(ssr)/./node_modules/unist-util-position/lib/index.js\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var hast_util_from_parse5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-from-parse5 */ \"(ssr)/./node_modules/hast-util-from-parse5/lib/index.js\");\n/* harmony import */ var hast_util_to_parse5__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! hast-util-to-parse5 */ \"(ssr)/./node_modules/hast-util-to-parse5/lib/index.js\");\n/* harmony import */ var html_void_elements__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! html-void-elements */ \"(ssr)/./node_modules/html-void-elements/index.js\");\n/* harmony import */ var web_namespaces__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! web-namespaces */ \"(ssr)/./node_modules/web-namespaces/index.js\");\n/* harmony import */ var zwitch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zwitch */ \"(ssr)/./node_modules/zwitch/index.js\");\n/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {import('../complex-types').Raw} Raw\n *\n * @typedef {Omit<Comment, 'value'> & {value: {stitch: Node}}} Stitch\n *\n * @typedef Options\n * @property {Array<string>} [passThrough]\n *   List of custom hast node types to pass through (keep) in hast.\n *   If the passed through nodes have children, those children are expected to\n *   be hast and will be handled.\n *\n * @typedef HiddenTokenizer\n * @property {Array<HiddenLocationTracker>} __mixins\n *   Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {() => number} _consume\n * @property {Array<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array<number>} tempBuff\n * @property {Function} _flushCodePointsConsumedAsCharacterReference\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n * @property {Function} NAMED_CHARACTER_REFERENCE_STATE\n * @property {Function} NUMERIC_CHARACTER_REFERENCE_END_STATE\n *\n * @typedef {Record<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n\n// @ts-expect-error: untyped.\n\n\n\n\n\n\n\n\n\nconst inTemplateMode = 'IN_TEMPLATE_MODE'\nconst dataState = 'DATA_STATE'\nconst characterToken = 'CHARACTER_TOKEN'\nconst startTagToken = 'START_TAG_TOKEN'\nconst endTagToken = 'END_TAG_TOKEN'\nconst commentToken = 'COMMENT_TOKEN'\nconst doctypeToken = 'DOCTYPE_TOKEN'\n\n/** @type {P5ParserOptions} */\nconst parseOptions = {sourceCodeLocationInfo: true, scriptingEnabled: false}\n\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param tree\n *   Original hast tree.\n * @param file\n *   Virtual file for positional info, optional.\n * @param options\n *   Configuration.\n */\nconst raw =\n  /**\n   * @type {(\n   *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &\n   *   ((tree: Node, options?: Options) => Node)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {VFile} [file]\n     * @param {Options} [options]\n     */\n    function (tree, file, options) {\n      let index = -1\n      const parser = new parse5_lib_parser_index_js__WEBPACK_IMPORTED_MODULE_0__(parseOptions)\n      const one = (0,zwitch__WEBPACK_IMPORTED_MODULE_1__.zwitch)('type', {\n        handlers: {root, element, text, comment, doctype, raw: handleRaw},\n        // @ts-expect-error: hush.\n        unknown\n      })\n      /** @type {boolean|undefined} */\n      let stitches\n      /** @type {HiddenTokenizer|undefined} */\n      let tokenizer\n      /** @type {HiddenPreprocessor|undefined} */\n      let preprocessor\n      /** @type {HiddenPosTracker|undefined} */\n      let posTracker\n      /** @type {HiddenLocationTracker|undefined} */\n      let locationTracker\n\n      if (isOptions(file)) {\n        options = file\n        file = undefined\n      }\n\n      if (options && options.passThrough) {\n        while (++index < options.passThrough.length) {\n          // @ts-expect-error: hush.\n          one.handlers[options.passThrough[index]] = stitch\n        }\n      }\n\n      const result = (0,hast_util_from_parse5__WEBPACK_IMPORTED_MODULE_2__.fromParse5)(\n        documentMode(tree) ? document() : fragment(),\n        file\n      )\n\n      if (stitches) {\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_3__.visit)(result, 'comment', (node, index, parent) => {\n          const stitch = /** @type {Stitch} */ (/** @type {unknown} */ (node))\n          if (stitch.value.stitch && parent !== null && index !== null) {\n            // @ts-expect-error: assume the stitch is allowed.\n            parent.children[index] = stitch.value.stitch\n            return index\n          }\n        })\n      }\n\n      // Unpack if possible and when not given a `root`.\n      if (\n        tree.type !== 'root' &&\n        result.type === 'root' &&\n        result.children.length === 1\n      ) {\n        return result.children[0]\n      }\n\n      return result\n\n      /**\n       * @returns {P5Fragment}\n       */\n      function fragment() {\n        /** @type {P5Element} */\n        const context = {\n          nodeName: 'template',\n          tagName: 'template',\n          attrs: [],\n          namespaceURI: web_namespaces__WEBPACK_IMPORTED_MODULE_4__.webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Element} */\n        const mock = {\n          nodeName: 'documentmock',\n          tagName: 'documentmock',\n          attrs: [],\n          namespaceURI: web_namespaces__WEBPACK_IMPORTED_MODULE_4__.webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Fragment} */\n        const doc = {nodeName: '#document-fragment', childNodes: []}\n\n        parser._bootstrap(mock, context)\n        parser._pushTmplInsertionMode(inTemplateMode)\n        parser._initTokenizerForFragmentParsing()\n        parser._insertFakeRootElement()\n        parser._resetInsertionMode()\n        parser._findFormInFragmentContext()\n\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        parser._adoptNodes(mock.childNodes[0], doc)\n\n        return doc\n      }\n\n      /**\n       * @returns {P5Document}\n       */\n      function document() {\n        /** @type {P5Document} */\n        const doc = parser.treeAdapter.createDocument()\n\n        parser._bootstrap(doc, undefined)\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        return doc\n      }\n\n      /**\n       * @param {Array<Content>} nodes\n       * @returns {void}\n       */\n      function all(nodes) {\n        let index = -1\n\n        /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n        if (nodes) {\n          while (++index < nodes.length) {\n            one(nodes[index])\n          }\n        }\n      }\n\n      /**\n       * @param {Root} node\n       * @returns {void}\n       */\n      function root(node) {\n        all(node.children)\n      }\n\n      /**\n       * @param {Element} node\n       * @returns {void}\n       */\n      function element(node) {\n        resetTokenizer()\n        parser._processInputToken(startTag(node))\n\n        all(node.children)\n\n        if (!html_void_elements__WEBPACK_IMPORTED_MODULE_5__.htmlVoidElements.includes(node.tagName)) {\n          resetTokenizer()\n          parser._processInputToken(endTag(node))\n        }\n      }\n\n      /**\n       * @param {Text} node\n       * @returns {void}\n       */\n      function text(node) {\n        resetTokenizer()\n        parser._processInputToken({\n          type: characterToken,\n          chars: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Doctype} node\n       * @returns {void}\n       */\n      function doctype(node) {\n        resetTokenizer()\n        parser._processInputToken({\n          type: doctypeToken,\n          name: 'html',\n          forceQuirks: false,\n          publicId: '',\n          systemId: '',\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Comment|Stitch} node\n       * @returns {void}\n       */\n      function comment(node) {\n        resetTokenizer()\n        parser._processInputToken({\n          type: commentToken,\n          data: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Raw} node\n       * @returns {void}\n       */\n      function handleRaw(node) {\n        const start = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_6__.pointStart)(node)\n        const line = start.line || 1\n        const column = start.column || 1\n        const offset = start.offset || 0\n\n        /* c8 ignore next 4 */\n        if (!preprocessor) throw new Error('Expected `preprocessor`')\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n        if (!locationTracker) throw new Error('Expected `locationTracker`')\n\n        // Reset preprocessor:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js#L17>.\n        preprocessor.html = undefined\n        preprocessor.pos = -1\n        preprocessor.lastGapPos = -1\n        preprocessor.lastCharPos = -1\n        preprocessor.gapStack = []\n        preprocessor.skipNextNewLine = false\n        preprocessor.lastChunkWritten = false\n        preprocessor.endOfChunkHit = false\n\n        // Reset preprocessor mixin:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n        posTracker.isEol = false\n        posTracker.lineStartPos = -column + 1 // Looks weird, but ensures we get correct positional info.\n        posTracker.droppedBufferSize = offset\n        posTracker.offset = 0\n        posTracker.col = 1\n        posTracker.line = line\n\n        // Reset location tracker:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n        locationTracker.currentAttrLocation = undefined\n        locationTracker.ctLoc = createParse5Location(node)\n\n        // See the code for `parse` and `parseFragment`:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n        tokenizer.write(node.value)\n        parser._runParsingLoop(null)\n\n        // Character references hang, so if we ended there, we need to flush\n        // those too.\n        // We reset the preprocessor as if the document ends here.\n        // Then one single call to the relevant state does the trick, parse5\n        // consumes the whole token.\n        if (\n          tokenizer.state === 'NAMED_CHARACTER_REFERENCE_STATE' ||\n          tokenizer.state === 'NUMERIC_CHARACTER_REFERENCE_END_STATE'\n        ) {\n          preprocessor.lastChunkWritten = true\n          tokenizer[tokenizer.state](tokenizer._consume())\n        }\n      }\n\n      /**\n       * @param {Node} node\n       */\n      function stitch(node) {\n        stitches = true\n\n        /** @type {Node} */\n        let clone\n\n        // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n        // passed through node).\n        if ('children' in node) {\n          clone = {\n            ...node,\n            children: raw(\n              {type: 'root', children: node.children},\n              file,\n              options\n              // @ts-expect-error Assume a given parent yields a parent.\n            ).children\n          }\n        } else {\n          clone = {...node}\n        }\n\n        // Hack: `value` is supposed to be a string, but as none of the tools\n        // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n        // through.\n        comment({type: 'comment', value: {stitch: clone}})\n      }\n\n      function resetTokenizer() {\n        /* c8 ignore next 2 */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n\n        // Process final characters if theyâ€™re still there after hibernating.\n        // Similar to:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n        const token = tokenizer.currentCharacterToken\n\n        if (token) {\n          token.location.endLine = posTracker.line\n          token.location.endCol = posTracker.col + 1\n          token.location.endOffset = posTracker.offset + 1\n          parser._processInputToken(token)\n        }\n\n        // Reset tokenizer:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n        // Especially putting it back in the `data` state is useful: some elements,\n        // like textareas and iframes, change the state.\n        // See GH-7.\n        // But also if broken HTML is in `raw`, and then a correct element is given.\n        // See GH-11.\n        tokenizer.tokenQueue = []\n        tokenizer.state = dataState\n        tokenizer.returnState = ''\n        tokenizer.charRefCode = -1\n        tokenizer.tempBuff = []\n        tokenizer.lastStartTagName = ''\n        tokenizer.consumedAfterSnapshot = -1\n        tokenizer.active = false\n        tokenizer.currentCharacterToken = undefined\n        tokenizer.currentToken = undefined\n        tokenizer.currentAttr = undefined\n      }\n    }\n  )\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction startTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location\n  }\n}\n\n/**\n * @param {Element} node\n * @returns {Array<P5Attribute>}\n */\nfunction attributes(node) {\n  return (0,hast_util_to_parse5__WEBPACK_IMPORTED_MODULE_7__.toParse5)({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: []\n    // @ts-expect-error Assume element.\n  }).attrs\n}\n\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction endTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location\n  }\n}\n\n/**\n * @param {Node} node\n */\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node')\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node\n  return Boolean(\n    head &&\n      (head.type === 'doctype' ||\n        (head.type === 'element' && head.tagName === 'html'))\n  )\n}\n\n/**\n * @param {Node|Stitch} node\n * @returns {P5Location}\n */\nfunction createParse5Location(node) {\n  const start = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_6__.pointStart)(node)\n  const end = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_6__.pointEnd)(node)\n\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  }\n}\n\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXJhdy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyxhQUFhLDJCQUEyQjtBQUN4QyxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLDhDQUE4QztBQUMzRCxhQUFhLDRCQUE0QjtBQUN6QyxhQUFhLGdFQUFnRSw2REFBNkQ7QUFDMUksYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSxjQUFjO0FBQzNCLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0EsYUFBYSwwQkFBMEIsUUFBUSxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLHlCQUF5QjtBQUN2QyxjQUFjLGNBQWM7QUFDNUIsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLFNBQVM7QUFDdkIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QjtBQUNBLGFBQWEsMkJBQTJCLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsU0FB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QUNiO0FBQ0E7QUFDQSxTQUFTLDZEQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFVO0FBQzFCLGNBQWMsNkRBQVE7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NhZGVuY2UtY29va2Jvb2svLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXJhdy9saWIvaW5kZXguanM/NTVhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3ZmaWxlJykuVkZpbGV9IFZGaWxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdwYXJzZTUnKS5Eb2N1bWVudH0gUDVEb2N1bWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgncGFyc2U1JykuRG9jdW1lbnRGcmFnbWVudH0gUDVGcmFnbWVudFxuICogQHR5cGVkZWYge09taXQ8aW1wb3J0KCdwYXJzZTUnKS5FbGVtZW50LCAncGFyZW50Tm9kZSc+fSBQNUVsZW1lbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3BhcnNlNScpLkF0dHJpYnV0ZX0gUDVBdHRyaWJ1dGVcbiAqIEB0eXBlZGVmIHtPbWl0PGltcG9ydCgncGFyc2U1JykuTG9jYXRpb24sICdzdGFydE9mZnNldCcgfCAnZW5kT2Zmc2V0Jz4gJiB7c3RhcnRPZmZzZXQ6IG51bWJlcnx1bmRlZmluZWQsIGVuZE9mZnNldDogbnVtYmVyfHVuZGVmaW5lZH19IFA1TG9jYXRpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3BhcnNlNScpLlBhcnNlck9wdGlvbnN9IFA1UGFyc2VyT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Eb2NUeXBlfSBEb2N0eXBlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuRWxlbWVudH0gRWxlbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLlRleHR9IFRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Db21tZW50fSBDb21tZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuQ29udGVudH0gQ29udGVudFxuICogQHR5cGVkZWYge1Jvb3R8Q29udGVudH0gTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vY29tcGxleC10eXBlcycpLlJhd30gUmF3XG4gKlxuICogQHR5cGVkZWYge09taXQ8Q29tbWVudCwgJ3ZhbHVlJz4gJiB7dmFsdWU6IHtzdGl0Y2g6IE5vZGV9fX0gU3RpdGNoXG4gKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbcGFzc1Rocm91Z2hdXG4gKiAgIExpc3Qgb2YgY3VzdG9tIGhhc3Qgbm9kZSB0eXBlcyB0byBwYXNzIHRocm91Z2ggKGtlZXApIGluIGhhc3QuXG4gKiAgIElmIHRoZSBwYXNzZWQgdGhyb3VnaCBub2RlcyBoYXZlIGNoaWxkcmVuLCB0aG9zZSBjaGlsZHJlbiBhcmUgZXhwZWN0ZWQgdG9cbiAqICAgYmUgaGFzdCBhbmQgd2lsbCBiZSBoYW5kbGVkLlxuICpcbiAqIEB0eXBlZGVmIEhpZGRlblRva2VuaXplclxuICogQHByb3BlcnR5IHtBcnJheTxIaWRkZW5Mb2NhdGlvblRyYWNrZXI+fSBfX21peGluc1xuICogICBXYXkgdG9vIHNpbXBsZSwgYnV0IHdvcmtzIGZvciB1cy5cbiAqIEBwcm9wZXJ0eSB7SGlkZGVuUHJlcHJvY2Vzc29yfSBwcmVwcm9jZXNzb3JcbiAqIEBwcm9wZXJ0eSB7KHZhbHVlOiBzdHJpbmcpID0+IHZvaWR9IHdyaXRlXG4gKiBAcHJvcGVydHkgeygpID0+IG51bWJlcn0gX2NvbnN1bWVcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8SGlkZGVuVG9rZW4+fSB0b2tlblF1ZXVlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXR1cm5TdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNoYXJSZWZDb2RlXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IHRlbXBCdWZmXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBfZmx1c2hDb2RlUG9pbnRzQ29uc3VtZWRBc0NoYXJhY3RlclJlZmVyZW5jZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxhc3RTdGFydFRhZ05hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb25zdW1lZEFmdGVyU25hcHNob3RcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWN0aXZlXG4gKiBAcHJvcGVydHkge0hpZGRlblRva2VufHVuZGVmaW5lZH0gY3VycmVudENoYXJhY3RlclRva2VuXG4gKiBAcHJvcGVydHkge0hpZGRlblRva2VufHVuZGVmaW5lZH0gY3VycmVudFRva2VuXG4gKiBAcHJvcGVydHkge3Vua25vd259IGN1cnJlbnRBdHRyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBOQU1FRF9DSEFSQUNURVJfUkVGRVJFTkNFX1NUQVRFXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBOVU1FUklDX0NIQVJBQ1RFUl9SRUZFUkVOQ0VfRU5EX1NUQVRFXG4gKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIHVua25vd24+ICYge2xvY2F0aW9uOiBQNUxvY2F0aW9ufX0gSGlkZGVuVG9rZW5cbiAqXG4gKiBAdHlwZWRlZiBIaWRkZW5QcmVwcm9jZXNzb3JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHVuZGVmaW5lZH0gaHRtbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBvc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RHYXBQb3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0Q2hhclBvc1xuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBnYXBTdGFja1xuICogQHByb3BlcnR5IHtib29sZWFufSBza2lwTmV4dE5ld0xpbmVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGFzdENodW5rV3JpdHRlblxuICogQHByb3BlcnR5IHtib29sZWFufSBlbmRPZkNodW5rSGl0XG4gKlxuICogQHR5cGVkZWYgSGlkZGVuTG9jYXRpb25UcmFja2VyXG4gKiBAcHJvcGVydHkge1A1TG9jYXRpb258dW5kZWZpbmVkfSBjdXJyZW50QXR0ckxvY2F0aW9uXG4gKiBAcHJvcGVydHkge1A1TG9jYXRpb259IGN0TG9jXG4gKiBAcHJvcGVydHkge0hpZGRlblBvc1RyYWNrZXJ9IHBvc1RyYWNrZXJcbiAqXG4gKiBAdHlwZWRlZiBIaWRkZW5Qb3NUcmFja2VyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRW9sXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZVN0YXJ0UG9zXG4gKiBAcHJvcGVydHkge251bWJlcn0gZHJvcHBlZEJ1ZmZlclNpemVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lXG4gKi9cblxuLy8gQHRzLWV4cGVjdC1lcnJvcjogdW50eXBlZC5cbmltcG9ydCBQYXJzZXIgZnJvbSAncGFyc2U1L2xpYi9wYXJzZXIvaW5kZXguanMnXG5pbXBvcnQge3BvaW50U3RhcnQsIHBvaW50RW5kfSBmcm9tICd1bmlzdC11dGlsLXBvc2l0aW9uJ1xuaW1wb3J0IHt2aXNpdH0gZnJvbSAndW5pc3QtdXRpbC12aXNpdCdcbmltcG9ydCB7ZnJvbVBhcnNlNX0gZnJvbSAnaGFzdC11dGlsLWZyb20tcGFyc2U1J1xuaW1wb3J0IHt0b1BhcnNlNX0gZnJvbSAnaGFzdC11dGlsLXRvLXBhcnNlNSdcbmltcG9ydCB7aHRtbFZvaWRFbGVtZW50c30gZnJvbSAnaHRtbC12b2lkLWVsZW1lbnRzJ1xuaW1wb3J0IHt3ZWJOYW1lc3BhY2VzfSBmcm9tICd3ZWItbmFtZXNwYWNlcydcbmltcG9ydCB7endpdGNofSBmcm9tICd6d2l0Y2gnXG5cbmNvbnN0IGluVGVtcGxhdGVNb2RlID0gJ0lOX1RFTVBMQVRFX01PREUnXG5jb25zdCBkYXRhU3RhdGUgPSAnREFUQV9TVEFURSdcbmNvbnN0IGNoYXJhY3RlclRva2VuID0gJ0NIQVJBQ1RFUl9UT0tFTidcbmNvbnN0IHN0YXJ0VGFnVG9rZW4gPSAnU1RBUlRfVEFHX1RPS0VOJ1xuY29uc3QgZW5kVGFnVG9rZW4gPSAnRU5EX1RBR19UT0tFTidcbmNvbnN0IGNvbW1lbnRUb2tlbiA9ICdDT01NRU5UX1RPS0VOJ1xuY29uc3QgZG9jdHlwZVRva2VuID0gJ0RPQ1RZUEVfVE9LRU4nXG5cbi8qKiBAdHlwZSB7UDVQYXJzZXJPcHRpb25zfSAqL1xuY29uc3QgcGFyc2VPcHRpb25zID0ge3NvdXJjZUNvZGVMb2NhdGlvbkluZm86IHRydWUsIHNjcmlwdGluZ0VuYWJsZWQ6IGZhbHNlfVxuXG4vKipcbiAqIEdpdmVuIGEgaGFzdCB0cmVlIGFuZCBhbiBvcHRpb25hbCB2ZmlsZSAoZm9yIHBvc2l0aW9uYWwgaW5mbyksIHJldHVybiBhIG5ld1xuICogcGFyc2VkLWFnYWluIGhhc3QgdHJlZS5cbiAqXG4gKiBAcGFyYW0gdHJlZVxuICogICBPcmlnaW5hbCBoYXN0IHRyZWUuXG4gKiBAcGFyYW0gZmlsZVxuICogICBWaXJ0dWFsIGZpbGUgZm9yIHBvc2l0aW9uYWwgaW5mbywgb3B0aW9uYWwuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICovXG5leHBvcnQgY29uc3QgcmF3ID1cbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKCh0cmVlOiBOb2RlLCBmaWxlOiBWRmlsZXx1bmRlZmluZWQsIG9wdGlvbnM/OiBPcHRpb25zKSA9PiBOb2RlKSAmXG4gICAqICAgKCh0cmVlOiBOb2RlLCBvcHRpb25zPzogT3B0aW9ucykgPT4gTm9kZSlcbiAgICogKX1cbiAgICovXG4gIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRyZWVcbiAgICAgKiBAcGFyYW0ge1ZGaWxlfSBbZmlsZV1cbiAgICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0cmVlLCBmaWxlLCBvcHRpb25zKSB7XG4gICAgICBsZXQgaW5kZXggPSAtMVxuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihwYXJzZU9wdGlvbnMpXG4gICAgICBjb25zdCBvbmUgPSB6d2l0Y2goJ3R5cGUnLCB7XG4gICAgICAgIGhhbmRsZXJzOiB7cm9vdCwgZWxlbWVudCwgdGV4dCwgY29tbWVudCwgZG9jdHlwZSwgcmF3OiBoYW5kbGVSYXd9LFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBodXNoLlxuICAgICAgICB1bmtub3duXG4gICAgICB9KVxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBzdGl0Y2hlc1xuICAgICAgLyoqIEB0eXBlIHtIaWRkZW5Ub2tlbml6ZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IHRva2VuaXplclxuICAgICAgLyoqIEB0eXBlIHtIaWRkZW5QcmVwcm9jZXNzb3J8dW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IHByZXByb2Nlc3NvclxuICAgICAgLyoqIEB0eXBlIHtIaWRkZW5Qb3NUcmFja2VyfHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBwb3NUcmFja2VyXG4gICAgICAvKiogQHR5cGUge0hpZGRlbkxvY2F0aW9uVHJhY2tlcnx1bmRlZmluZWR9ICovXG4gICAgICBsZXQgbG9jYXRpb25UcmFja2VyXG5cbiAgICAgIGlmIChpc09wdGlvbnMoZmlsZSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IGZpbGVcbiAgICAgICAgZmlsZSA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBhc3NUaHJvdWdoKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgb3B0aW9ucy5wYXNzVGhyb3VnaC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBodXNoLlxuICAgICAgICAgIG9uZS5oYW5kbGVyc1tvcHRpb25zLnBhc3NUaHJvdWdoW2luZGV4XV0gPSBzdGl0Y2hcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBmcm9tUGFyc2U1KFxuICAgICAgICBkb2N1bWVudE1vZGUodHJlZSkgPyBkb2N1bWVudCgpIDogZnJhZ21lbnQoKSxcbiAgICAgICAgZmlsZVxuICAgICAgKVxuXG4gICAgICBpZiAoc3RpdGNoZXMpIHtcbiAgICAgICAgdmlzaXQocmVzdWx0LCAnY29tbWVudCcsIChub2RlLCBpbmRleCwgcGFyZW50KSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RpdGNoID0gLyoqIEB0eXBlIHtTdGl0Y2h9ICovICgvKiogQHR5cGUge3Vua25vd259ICovIChub2RlKSlcbiAgICAgICAgICBpZiAoc3RpdGNoLnZhbHVlLnN0aXRjaCAmJiBwYXJlbnQgIT09IG51bGwgJiYgaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGFzc3VtZSB0aGUgc3RpdGNoIGlzIGFsbG93ZWQuXG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5baW5kZXhdID0gc3RpdGNoLnZhbHVlLnN0aXRjaFxuICAgICAgICAgICAgcmV0dXJuIGluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBVbnBhY2sgaWYgcG9zc2libGUgYW5kIHdoZW4gbm90IGdpdmVuIGEgYHJvb3RgLlxuICAgICAgaWYgKFxuICAgICAgICB0cmVlLnR5cGUgIT09ICdyb290JyAmJlxuICAgICAgICByZXN1bHQudHlwZSA9PT0gJ3Jvb3QnICYmXG4gICAgICAgIHJlc3VsdC5jaGlsZHJlbi5sZW5ndGggPT09IDFcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNoaWxkcmVuWzBdXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcblxuICAgICAgLyoqXG4gICAgICAgKiBAcmV0dXJucyB7UDVGcmFnbWVudH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZnJhZ21lbnQoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7UDVFbGVtZW50fSAqL1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgIG5vZGVOYW1lOiAndGVtcGxhdGUnLFxuICAgICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZScsXG4gICAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICAgIG5hbWVzcGFjZVVSSTogd2ViTmFtZXNwYWNlcy5odG1sLFxuICAgICAgICAgIGNoaWxkTm9kZXM6IFtdXG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHtQNUVsZW1lbnR9ICovXG4gICAgICAgIGNvbnN0IG1vY2sgPSB7XG4gICAgICAgICAgbm9kZU5hbWU6ICdkb2N1bWVudG1vY2snLFxuICAgICAgICAgIHRhZ05hbWU6ICdkb2N1bWVudG1vY2snLFxuICAgICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgICBuYW1lc3BhY2VVUkk6IHdlYk5hbWVzcGFjZXMuaHRtbCxcbiAgICAgICAgICBjaGlsZE5vZGVzOiBbXVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7UDVGcmFnbWVudH0gKi9cbiAgICAgICAgY29uc3QgZG9jID0ge25vZGVOYW1lOiAnI2RvY3VtZW50LWZyYWdtZW50JywgY2hpbGROb2RlczogW119XG5cbiAgICAgICAgcGFyc2VyLl9ib290c3RyYXAobW9jaywgY29udGV4dClcbiAgICAgICAgcGFyc2VyLl9wdXNoVG1wbEluc2VydGlvbk1vZGUoaW5UZW1wbGF0ZU1vZGUpXG4gICAgICAgIHBhcnNlci5faW5pdFRva2VuaXplckZvckZyYWdtZW50UGFyc2luZygpXG4gICAgICAgIHBhcnNlci5faW5zZXJ0RmFrZVJvb3RFbGVtZW50KClcbiAgICAgICAgcGFyc2VyLl9yZXNldEluc2VydGlvbk1vZGUoKVxuICAgICAgICBwYXJzZXIuX2ZpbmRGb3JtSW5GcmFnbWVudENvbnRleHQoKVxuXG4gICAgICAgIHRva2VuaXplciA9IHBhcnNlci50b2tlbml6ZXJcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKCF0b2tlbml6ZXIpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYHRva2VuaXplcmAnKVxuICAgICAgICBwcmVwcm9jZXNzb3IgPSB0b2tlbml6ZXIucHJlcHJvY2Vzc29yXG4gICAgICAgIGxvY2F0aW9uVHJhY2tlciA9IHRva2VuaXplci5fX21peGluc1swXVxuICAgICAgICBwb3NUcmFja2VyID0gbG9jYXRpb25UcmFja2VyLnBvc1RyYWNrZXJcblxuICAgICAgICBvbmUodHJlZSlcblxuICAgICAgICByZXNldFRva2VuaXplcigpXG5cbiAgICAgICAgcGFyc2VyLl9hZG9wdE5vZGVzKG1vY2suY2hpbGROb2Rlc1swXSwgZG9jKVxuXG4gICAgICAgIHJldHVybiBkb2NcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcmV0dXJucyB7UDVEb2N1bWVudH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZG9jdW1lbnQoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7UDVEb2N1bWVudH0gKi9cbiAgICAgICAgY29uc3QgZG9jID0gcGFyc2VyLnRyZWVBZGFwdGVyLmNyZWF0ZURvY3VtZW50KClcblxuICAgICAgICBwYXJzZXIuX2Jvb3RzdHJhcChkb2MsIHVuZGVmaW5lZClcbiAgICAgICAgdG9rZW5pemVyID0gcGFyc2VyLnRva2VuaXplclxuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoIXRva2VuaXplcikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBgdG9rZW5pemVyYCcpXG4gICAgICAgIHByZXByb2Nlc3NvciA9IHRva2VuaXplci5wcmVwcm9jZXNzb3JcbiAgICAgICAgbG9jYXRpb25UcmFja2VyID0gdG9rZW5pemVyLl9fbWl4aW5zWzBdXG4gICAgICAgIHBvc1RyYWNrZXIgPSBsb2NhdGlvblRyYWNrZXIucG9zVHJhY2tlclxuXG4gICAgICAgIG9uZSh0cmVlKVxuXG4gICAgICAgIHJlc2V0VG9rZW5pemVyKClcblxuICAgICAgICByZXR1cm4gZG9jXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtBcnJheTxDb250ZW50Pn0gbm9kZXNcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBhbGwobm9kZXMpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIGludmFsaWQgbm9kZXMsIHNlZSByZWh5cGVqcy9yZWh5cGUtcmF3IzcuICovXG4gICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvbmUobm9kZXNbaW5kZXhdKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Um9vdH0gbm9kZVxuICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJvb3Qobm9kZSkge1xuICAgICAgICBhbGwobm9kZS5jaGlsZHJlbilcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBlbGVtZW50KG5vZGUpIHtcbiAgICAgICAgcmVzZXRUb2tlbml6ZXIoKVxuICAgICAgICBwYXJzZXIuX3Byb2Nlc3NJbnB1dFRva2VuKHN0YXJ0VGFnKG5vZGUpKVxuXG4gICAgICAgIGFsbChub2RlLmNoaWxkcmVuKVxuXG4gICAgICAgIGlmICghaHRtbFZvaWRFbGVtZW50cy5pbmNsdWRlcyhub2RlLnRhZ05hbWUpKSB7XG4gICAgICAgICAgcmVzZXRUb2tlbml6ZXIoKVxuICAgICAgICAgIHBhcnNlci5fcHJvY2Vzc0lucHV0VG9rZW4oZW5kVGFnKG5vZGUpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtUZXh0fSBub2RlXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdGV4dChub2RlKSB7XG4gICAgICAgIHJlc2V0VG9rZW5pemVyKClcbiAgICAgICAgcGFyc2VyLl9wcm9jZXNzSW5wdXRUb2tlbih7XG4gICAgICAgICAgdHlwZTogY2hhcmFjdGVyVG9rZW4sXG4gICAgICAgICAgY2hhcnM6IG5vZGUudmFsdWUsXG4gICAgICAgICAgbG9jYXRpb246IGNyZWF0ZVBhcnNlNUxvY2F0aW9uKG5vZGUpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtEb2N0eXBlfSBub2RlXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZG9jdHlwZShub2RlKSB7XG4gICAgICAgIHJlc2V0VG9rZW5pemVyKClcbiAgICAgICAgcGFyc2VyLl9wcm9jZXNzSW5wdXRUb2tlbih7XG4gICAgICAgICAgdHlwZTogZG9jdHlwZVRva2VuLFxuICAgICAgICAgIG5hbWU6ICdodG1sJyxcbiAgICAgICAgICBmb3JjZVF1aXJrczogZmFsc2UsXG4gICAgICAgICAgcHVibGljSWQ6ICcnLFxuICAgICAgICAgIHN5c3RlbUlkOiAnJyxcbiAgICAgICAgICBsb2NhdGlvbjogY3JlYXRlUGFyc2U1TG9jYXRpb24obm9kZSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0NvbW1lbnR8U3RpdGNofSBub2RlXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gY29tbWVudChub2RlKSB7XG4gICAgICAgIHJlc2V0VG9rZW5pemVyKClcbiAgICAgICAgcGFyc2VyLl9wcm9jZXNzSW5wdXRUb2tlbih7XG4gICAgICAgICAgdHlwZTogY29tbWVudFRva2VuLFxuICAgICAgICAgIGRhdGE6IG5vZGUudmFsdWUsXG4gICAgICAgICAgbG9jYXRpb246IGNyZWF0ZVBhcnNlNUxvY2F0aW9uKG5vZGUpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtSYXd9IG5vZGVcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBoYW5kbGVSYXcobm9kZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHBvaW50U3RhcnQobm9kZSlcbiAgICAgICAgY29uc3QgbGluZSA9IHN0YXJ0LmxpbmUgfHwgMVxuICAgICAgICBjb25zdCBjb2x1bW4gPSBzdGFydC5jb2x1bW4gfHwgMVxuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydC5vZmZzZXQgfHwgMFxuXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDQgKi9cbiAgICAgICAgaWYgKCFwcmVwcm9jZXNzb3IpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYHByZXByb2Nlc3NvcmAnKVxuICAgICAgICBpZiAoIXRva2VuaXplcikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBgdG9rZW5pemVyYCcpXG4gICAgICAgIGlmICghcG9zVHJhY2tlcikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBgcG9zVHJhY2tlcmAnKVxuICAgICAgICBpZiAoIWxvY2F0aW9uVHJhY2tlcikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBgbG9jYXRpb25UcmFja2VyYCcpXG5cbiAgICAgICAgLy8gUmVzZXQgcHJlcHJvY2Vzc29yOlxuICAgICAgICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L2Jsb2IvOWM2ODNlMS9wYWNrYWdlcy9wYXJzZTUvbGliL3Rva2VuaXplci9wcmVwcm9jZXNzb3IuanMjTDE3Pi5cbiAgICAgICAgcHJlcHJvY2Vzc29yLmh0bWwgPSB1bmRlZmluZWRcbiAgICAgICAgcHJlcHJvY2Vzc29yLnBvcyA9IC0xXG4gICAgICAgIHByZXByb2Nlc3Nvci5sYXN0R2FwUG9zID0gLTFcbiAgICAgICAgcHJlcHJvY2Vzc29yLmxhc3RDaGFyUG9zID0gLTFcbiAgICAgICAgcHJlcHJvY2Vzc29yLmdhcFN0YWNrID0gW11cbiAgICAgICAgcHJlcHJvY2Vzc29yLnNraXBOZXh0TmV3TGluZSA9IGZhbHNlXG4gICAgICAgIHByZXByb2Nlc3Nvci5sYXN0Q2h1bmtXcml0dGVuID0gZmFsc2VcbiAgICAgICAgcHJlcHJvY2Vzc29yLmVuZE9mQ2h1bmtIaXQgPSBmYWxzZVxuXG4gICAgICAgIC8vIFJlc2V0IHByZXByb2Nlc3NvciBtaXhpbjpcbiAgICAgICAgLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL2luaWt1bGluL3BhcnNlNS9ibG9iLzljNjgzZTEvcGFja2FnZXMvcGFyc2U1L2xpYi9leHRlbnNpb25zL3Bvc2l0aW9uLXRyYWNraW5nL3ByZXByb2Nlc3Nvci1taXhpbi5qcz4uXG4gICAgICAgIHBvc1RyYWNrZXIuaXNFb2wgPSBmYWxzZVxuICAgICAgICBwb3NUcmFja2VyLmxpbmVTdGFydFBvcyA9IC1jb2x1bW4gKyAxIC8vIExvb2tzIHdlaXJkLCBidXQgZW5zdXJlcyB3ZSBnZXQgY29ycmVjdCBwb3NpdGlvbmFsIGluZm8uXG4gICAgICAgIHBvc1RyYWNrZXIuZHJvcHBlZEJ1ZmZlclNpemUgPSBvZmZzZXRcbiAgICAgICAgcG9zVHJhY2tlci5vZmZzZXQgPSAwXG4gICAgICAgIHBvc1RyYWNrZXIuY29sID0gMVxuICAgICAgICBwb3NUcmFja2VyLmxpbmUgPSBsaW5lXG5cbiAgICAgICAgLy8gUmVzZXQgbG9jYXRpb24gdHJhY2tlcjpcbiAgICAgICAgLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL2luaWt1bGluL3BhcnNlNS9ibG9iLzljNjgzZTEvcGFja2FnZXMvcGFyc2U1L2xpYi9leHRlbnNpb25zL2xvY2F0aW9uLWluZm8vdG9rZW5pemVyLW1peGluLmpzPi5cbiAgICAgICAgbG9jYXRpb25UcmFja2VyLmN1cnJlbnRBdHRyTG9jYXRpb24gPSB1bmRlZmluZWRcbiAgICAgICAgbG9jYXRpb25UcmFja2VyLmN0TG9jID0gY3JlYXRlUGFyc2U1TG9jYXRpb24obm9kZSlcblxuICAgICAgICAvLyBTZWUgdGhlIGNvZGUgZm9yIGBwYXJzZWAgYW5kIGBwYXJzZUZyYWdtZW50YDpcbiAgICAgICAgLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL2luaWt1bGluL3BhcnNlNS9ibG9iLzljNjgzZTEvcGFja2FnZXMvcGFyc2U1L2xpYi9wYXJzZXIvaW5kZXguanMjTDM3MT4uXG4gICAgICAgIHRva2VuaXplci53cml0ZShub2RlLnZhbHVlKVxuICAgICAgICBwYXJzZXIuX3J1blBhcnNpbmdMb29wKG51bGwpXG5cbiAgICAgICAgLy8gQ2hhcmFjdGVyIHJlZmVyZW5jZXMgaGFuZywgc28gaWYgd2UgZW5kZWQgdGhlcmUsIHdlIG5lZWQgdG8gZmx1c2hcbiAgICAgICAgLy8gdGhvc2UgdG9vLlxuICAgICAgICAvLyBXZSByZXNldCB0aGUgcHJlcHJvY2Vzc29yIGFzIGlmIHRoZSBkb2N1bWVudCBlbmRzIGhlcmUuXG4gICAgICAgIC8vIFRoZW4gb25lIHNpbmdsZSBjYWxsIHRvIHRoZSByZWxldmFudCBzdGF0ZSBkb2VzIHRoZSB0cmljaywgcGFyc2U1XG4gICAgICAgIC8vIGNvbnN1bWVzIHRoZSB3aG9sZSB0b2tlbi5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRva2VuaXplci5zdGF0ZSA9PT0gJ05BTUVEX0NIQVJBQ1RFUl9SRUZFUkVOQ0VfU1RBVEUnIHx8XG4gICAgICAgICAgdG9rZW5pemVyLnN0YXRlID09PSAnTlVNRVJJQ19DSEFSQUNURVJfUkVGRVJFTkNFX0VORF9TVEFURSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgcHJlcHJvY2Vzc29yLmxhc3RDaHVua1dyaXR0ZW4gPSB0cnVlXG4gICAgICAgICAgdG9rZW5pemVyW3Rva2VuaXplci5zdGF0ZV0odG9rZW5pemVyLl9jb25zdW1lKCkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gc3RpdGNoKG5vZGUpIHtcbiAgICAgICAgc3RpdGNoZXMgPSB0cnVlXG5cbiAgICAgICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgICAgICBsZXQgY2xvbmVcblxuICAgICAgICAvLyBSZWN1cnNlLCBiZWNhdXNlIHRvIHNvbWV3aGF0IGhhbmRsZSBgWzx4Pl08L3g+YCAod2hlcmUgYFtdYCBkZW5vdGVzIHRoZVxuICAgICAgICAvLyBwYXNzZWQgdGhyb3VnaCBub2RlKS5cbiAgICAgICAgaWYgKCdjaGlsZHJlbicgaW4gbm9kZSkge1xuICAgICAgICAgIGNsb25lID0ge1xuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiByYXcoXG4gICAgICAgICAgICAgIHt0eXBlOiAncm9vdCcsIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVufSxcbiAgICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEFzc3VtZSBhIGdpdmVuIHBhcmVudCB5aWVsZHMgYSBwYXJlbnQuXG4gICAgICAgICAgICApLmNoaWxkcmVuXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lID0gey4uLm5vZGV9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYWNrOiBgdmFsdWVgIGlzIHN1cHBvc2VkIHRvIGJlIGEgc3RyaW5nLCBidXQgYXMgbm9uZSBvZiB0aGUgdG9vbHNcbiAgICAgICAgLy8gKGBwYXJzZTVgIG9yIGBoYXN0LXV0aWwtZnJvbS1wYXJzZTVgKSBsb29rcyBhdCBpdCwgd2UgY2FuIHBhc3Mgbm9kZXNcbiAgICAgICAgLy8gdGhyb3VnaC5cbiAgICAgICAgY29tbWVudCh7dHlwZTogJ2NvbW1lbnQnLCB2YWx1ZToge3N0aXRjaDogY2xvbmV9fSlcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVzZXRUb2tlbml6ZXIoKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICAgICAgaWYgKCF0b2tlbml6ZXIpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYHRva2VuaXplcmAnKVxuICAgICAgICBpZiAoIXBvc1RyYWNrZXIpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYHBvc1RyYWNrZXJgJylcblxuICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGNoYXJhY3RlcnMgaWYgdGhleeKAmXJlIHN0aWxsIHRoZXJlIGFmdGVyIGhpYmVybmF0aW5nLlxuICAgICAgICAvLyBTaW1pbGFyIHRvOlxuICAgICAgICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L2Jsb2IvOWM2ODNlMS9wYWNrYWdlcy9wYXJzZTUvbGliL2V4dGVuc2lvbnMvbG9jYXRpb24taW5mby90b2tlbml6ZXItbWl4aW4uanMjTDk1Pi5cbiAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbml6ZXIuY3VycmVudENoYXJhY3RlclRva2VuXG5cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgdG9rZW4ubG9jYXRpb24uZW5kTGluZSA9IHBvc1RyYWNrZXIubGluZVxuICAgICAgICAgIHRva2VuLmxvY2F0aW9uLmVuZENvbCA9IHBvc1RyYWNrZXIuY29sICsgMVxuICAgICAgICAgIHRva2VuLmxvY2F0aW9uLmVuZE9mZnNldCA9IHBvc1RyYWNrZXIub2Zmc2V0ICsgMVxuICAgICAgICAgIHBhcnNlci5fcHJvY2Vzc0lucHV0VG9rZW4odG9rZW4pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB0b2tlbml6ZXI6XG4gICAgICAgIC8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9pbmlrdWxpbi9wYXJzZTUvYmxvYi85YzY4M2UxL3BhY2thZ2VzL3BhcnNlNS9saWIvdG9rZW5pemVyL2luZGV4LmpzI0wyMTgtTDIzND4uXG4gICAgICAgIC8vIEVzcGVjaWFsbHkgcHV0dGluZyBpdCBiYWNrIGluIHRoZSBgZGF0YWAgc3RhdGUgaXMgdXNlZnVsOiBzb21lIGVsZW1lbnRzLFxuICAgICAgICAvLyBsaWtlIHRleHRhcmVhcyBhbmQgaWZyYW1lcywgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gU2VlIEdILTcuXG4gICAgICAgIC8vIEJ1dCBhbHNvIGlmIGJyb2tlbiBIVE1MIGlzIGluIGByYXdgLCBhbmQgdGhlbiBhIGNvcnJlY3QgZWxlbWVudCBpcyBnaXZlbi5cbiAgICAgICAgLy8gU2VlIEdILTExLlxuICAgICAgICB0b2tlbml6ZXIudG9rZW5RdWV1ZSA9IFtdXG4gICAgICAgIHRva2VuaXplci5zdGF0ZSA9IGRhdGFTdGF0ZVxuICAgICAgICB0b2tlbml6ZXIucmV0dXJuU3RhdGUgPSAnJ1xuICAgICAgICB0b2tlbml6ZXIuY2hhclJlZkNvZGUgPSAtMVxuICAgICAgICB0b2tlbml6ZXIudGVtcEJ1ZmYgPSBbXVxuICAgICAgICB0b2tlbml6ZXIubGFzdFN0YXJ0VGFnTmFtZSA9ICcnXG4gICAgICAgIHRva2VuaXplci5jb25zdW1lZEFmdGVyU25hcHNob3QgPSAtMVxuICAgICAgICB0b2tlbml6ZXIuYWN0aXZlID0gZmFsc2VcbiAgICAgICAgdG9rZW5pemVyLmN1cnJlbnRDaGFyYWN0ZXJUb2tlbiA9IHVuZGVmaW5lZFxuICAgICAgICB0b2tlbml6ZXIuY3VycmVudFRva2VuID0gdW5kZWZpbmVkXG4gICAgICAgIHRva2VuaXplci5jdXJyZW50QXR0ciA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cbiAgKVxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtIaWRkZW5Ub2tlbn1cbiAqL1xuZnVuY3Rpb24gc3RhcnRUYWcobm9kZSkge1xuICAvKiogQHR5cGUge1A1TG9jYXRpb259ICovXG4gIGNvbnN0IGxvY2F0aW9uID0gT2JqZWN0LmFzc2lnbihjcmVhdGVQYXJzZTVMb2NhdGlvbihub2RlKSlcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBleHRyYSBwb3NpdGlvbmFsIGluZm8uXG4gIGxvY2F0aW9uLnN0YXJ0VGFnID0gT2JqZWN0LmFzc2lnbih7fSwgbG9jYXRpb24pXG5cbiAgLy8gVW50eXBlZCB0b2tlbi5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBzdGFydFRhZ1Rva2VuLFxuICAgIHRhZ05hbWU6IG5vZGUudGFnTmFtZSxcbiAgICBzZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgYXR0cnM6IGF0dHJpYnV0ZXMobm9kZSksXG4gICAgbG9jYXRpb25cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0FycmF5PFA1QXR0cmlidXRlPn1cbiAqL1xuZnVuY3Rpb24gYXR0cmlidXRlcyhub2RlKSB7XG4gIHJldHVybiB0b1BhcnNlNSh7XG4gICAgdGFnTmFtZTogbm9kZS50YWdOYW1lLFxuICAgIHR5cGU6ICdlbGVtZW50JyxcbiAgICBwcm9wZXJ0aWVzOiBub2RlLnByb3BlcnRpZXMsXG4gICAgY2hpbGRyZW46IFtdXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBBc3N1bWUgZWxlbWVudC5cbiAgfSkuYXR0cnNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtIaWRkZW5Ub2tlbn1cbiAqL1xuZnVuY3Rpb24gZW5kVGFnKG5vZGUpIHtcbiAgLyoqIEB0eXBlIHtQNUxvY2F0aW9ufSAqL1xuICBjb25zdCBsb2NhdGlvbiA9IE9iamVjdC5hc3NpZ24oY3JlYXRlUGFyc2U1TG9jYXRpb24obm9kZSkpXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgZXh0cmEgcG9zaXRpb25hbCBpbmZvLlxuICBsb2NhdGlvbi5zdGFydFRhZyA9IE9iamVjdC5hc3NpZ24oe30sIGxvY2F0aW9uKVxuXG4gIC8vIFVudHlwZWQgdG9rZW4uXG4gIHJldHVybiB7XG4gICAgdHlwZTogZW5kVGFnVG9rZW4sXG4gICAgdGFnTmFtZTogbm9kZS50YWdOYW1lLFxuICAgIGF0dHJzOiBbXSxcbiAgICBsb2NhdGlvblxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKi9cbmZ1bmN0aW9uIHVua25vd24obm9kZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21waWxlIGAnICsgbm9kZS50eXBlICsgJ2Agbm9kZScpXG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZG9jdW1lbnRNb2RlKG5vZGUpIHtcbiAgY29uc3QgaGVhZCA9IG5vZGUudHlwZSA9PT0gJ3Jvb3QnID8gbm9kZS5jaGlsZHJlblswXSA6IG5vZGVcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgaGVhZCAmJlxuICAgICAgKGhlYWQudHlwZSA9PT0gJ2RvY3R5cGUnIHx8XG4gICAgICAgIChoZWFkLnR5cGUgPT09ICdlbGVtZW50JyAmJiBoZWFkLnRhZ05hbWUgPT09ICdodG1sJykpXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV8U3RpdGNofSBub2RlXG4gKiBAcmV0dXJucyB7UDVMb2NhdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFyc2U1TG9jYXRpb24obm9kZSkge1xuICBjb25zdCBzdGFydCA9IHBvaW50U3RhcnQobm9kZSlcbiAgY29uc3QgZW5kID0gcG9pbnRFbmQobm9kZSlcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0TGluZTogc3RhcnQubGluZSxcbiAgICBzdGFydENvbDogc3RhcnQuY29sdW1uLFxuICAgIHN0YXJ0T2Zmc2V0OiBzdGFydC5vZmZzZXQsXG4gICAgZW5kTGluZTogZW5kLmxpbmUsXG4gICAgZW5kQ29sOiBlbmQuY29sdW1uLFxuICAgIGVuZE9mZnNldDogZW5kLm9mZnNldFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtWRmlsZXxPcHRpb25zfHVuZGVmaW5lZH0gdmFsdWVcbiAqIEByZXR1cm4ge3ZhbHVlIGlzIE9wdGlvbnN9XG4gKi9cbmZ1bmN0aW9uIGlzT3B0aW9ucyh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSAmJiAhKCdtZXNzYWdlJyBpbiB2YWx1ZSAmJiAnbWVzc2FnZXMnIGluIHZhbHVlKSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hast-util-raw/lib/index.js\n");

/***/ })

};
;
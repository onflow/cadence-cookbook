"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-find-and-replace";
exports.ids = ["vendor-chunks/mdast-util-find-and-replace"];
exports.modules = {

/***/ "(ssr)/./node_modules/mdast-util-find-and-replace/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/lib/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAndReplace: () => (/* binding */ findAndReplace)\n/* harmony export */ });\n/* harmony import */ var escape_string_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! escape-string-regexp */ \"(ssr)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js\");\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-visit-parents */ \"(ssr)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-is */ \"(ssr)/./node_modules/unist-util-is/lib/index.js\");\n/**\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {Extract<Node, MdastParent>} Parent\n * @typedef {Exclude<Parent, Root>} ContentParent\n *\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[Root, ...Array<ContentParent>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {string | RegExp} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\n *   Several find and replaces, in object form.\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n * @typedef {string | ReplaceFunction} Replace\n *   Thing to replace with.\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore.\n */\n\n\n\n\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param tree\n *   Tree to change.\n * @param find\n *   Patterns to find.\n * @param replace\n *   Things to replace with (when `find` is `Find`) or configuration.\n * @param options\n *   Configuration (when `find` is not `Find`).\n * @returns\n *   Given, modified, tree.\n */\n// To do: next major: remove `find` & `replace` combo, remove schema.\nconst findAndReplace =\n  /**\n   * @type {(\n   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &\n   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)\n   * )}\n   **/\n  (\n    /**\n     * @template {Node} Tree\n     * @param {Tree} tree\n     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\n     * @param {Replace | Options | null | undefined} [replace]\n     * @param {Options | null | undefined} [options]\n     * @returns {Tree}\n     */\n    function (tree, find, replace, options) {\n      /** @type {Options | null | undefined} */\n      let settings\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n      let schema\n\n      if (typeof find === 'string' || find instanceof RegExp) {\n        // @ts-expect-error don’t expect options twice.\n        schema = [[find, replace]]\n        settings = options\n      } else {\n        schema = find\n        // @ts-expect-error don’t expect replace twice.\n        settings = replace\n      }\n\n      if (!settings) {\n        settings = {}\n      }\n\n      const ignored = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_1__.convert)(settings.ignore || [])\n      const pairs = toPairs(schema)\n      let pairIndex = -1\n\n      while (++pairIndex < pairs.length) {\n        (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(tree, 'text', visitor)\n      }\n\n      // To do next major: don’t return the given tree.\n      return tree\n\n      /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */\n      function visitor(node, parents) {\n        let index = -1\n        /** @type {Parent | undefined} */\n        let grandparent\n\n        while (++index < parents.length) {\n          const parent = parents[index]\n\n          if (\n            ignored(\n              parent,\n              // @ts-expect-error: TS doesn’t understand but it’s perfect.\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\n              grandparent\n            )\n          ) {\n            return\n          }\n\n          grandparent = parent\n        }\n\n        if (grandparent) {\n          return handler(node, parents)\n        }\n      }\n\n      /**\n       * Handle a text node which is not in an ignored parent.\n       *\n       * @param {Text} node\n       *   Text node.\n       * @param {Array<Parent>} parents\n       *   Parents.\n       * @returns {VisitorResult}\n       *   Result.\n       */\n      function handler(node, parents) {\n        const parent = parents[parents.length - 1]\n        const find = pairs[pairIndex][0]\n        const replace = pairs[pairIndex][1]\n        let start = 0\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        const index = parent.children.indexOf(node)\n        let change = false\n        /** @type {Array<PhrasingContent>} */\n        let nodes = []\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          const position = match.index\n          /** @type {RegExpMatchObject} */\n          const matchObject = {\n            index: match.index,\n            input: match.input,\n            // @ts-expect-error: stack is fine.\n            stack: [...parents, node]\n          }\n          let value = replace(...match, matchObject)\n\n          if (typeof value === 'string') {\n            value = value.length > 0 ? {type: 'text', value} : undefined\n          }\n\n          // It wasn’t a match after all.\n          if (value !== false) {\n            if (start !== position) {\n              nodes.push({\n                type: 'text',\n                value: node.value.slice(start, position)\n              })\n            }\n\n            if (Array.isArray(value)) {\n              nodes.push(...value)\n            } else if (value) {\n              nodes.push(value)\n            }\n\n            start = position + match[0].length\n            change = true\n          }\n\n          if (!find.global) {\n            break\n          }\n\n          match = find.exec(node.value)\n        }\n\n        if (change) {\n          if (start < node.value.length) {\n            nodes.push({type: 'text', value: node.value.slice(start)})\n          }\n\n          parent.children.splice(index, 1, ...nodes)\n        } else {\n          nodes = [node]\n        }\n\n        return index + nodes.length\n      }\n    }\n  )\n\n/**\n * Turn a schema into pairs.\n *\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema')\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    /** @type {string} */\n    let key\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])])\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp((0,escape_string_regexp__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLGlDQUFpQztBQUM5QyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLGtEQUFrRDtBQUMvRDs7QUFFQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBOztBQUV5QztBQUNZO0FBQ2hCOztBQUVyQyxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QixlQUFlLE1BQU07QUFDckIsZUFBZSxrREFBa0Q7QUFDakUsZUFBZSxzQ0FBc0M7QUFDckQsZUFBZSw0QkFBNEI7QUFDM0MsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0EsaUJBQWlCLHlDQUF5QztBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHNFQUFZO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGdGQUFnRjtBQUNqRztBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MscUJBQXFCO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsNkNBQTZDO0FBQ3JFOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnRUFBTTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NhZGVuY2UtY29va2Jvb2svLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL2xpYi9pbmRleC5qcz8zY2NmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QYXJlbnR9IE1kYXN0UGFyZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQ29udGVudH0gQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QaHJhc2luZ0NvbnRlbnR9IFBocmFzaW5nQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UZXh0fSBUZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnKS5UZXN0fSBUZXN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnKS5WaXNpdG9yUmVzdWx0fSBWaXNpdG9yUmVzdWx0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q29udGVudCB8IFJvb3R9IE5vZGVcbiAqIEB0eXBlZGVmIHtFeHRyYWN0PE5vZGUsIE1kYXN0UGFyZW50Pn0gUGFyZW50XG4gKiBAdHlwZWRlZiB7RXhjbHVkZTxQYXJlbnQsIFJvb3Q+fSBDb250ZW50UGFyZW50XG4gKlxuICogQHR5cGVkZWYgUmVnRXhwTWF0Y2hPYmplY3RcbiAqICAgSW5mbyBvbiB0aGUgbWF0Y2guXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXhcbiAqICAgVGhlIGluZGV4IG9mIHRoZSBzZWFyY2ggYXQgd2hpY2ggdGhlIHJlc3VsdCB3YXMgZm91bmQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaW5wdXRcbiAqICAgQSBjb3B5IG9mIHRoZSBzZWFyY2ggc3RyaW5nIGluIHRoZSB0ZXh0IG5vZGUuXG4gKiBAcHJvcGVydHkge1tSb290LCAuLi5BcnJheTxDb250ZW50UGFyZW50PiwgVGV4dF19IHN0YWNrXG4gKiAgIEFsbCBhbmNlc3RvcnMgb2YgdGhlIHRleHQgbm9kZSwgd2hlcmUgdGhlIGxhc3Qgbm9kZSBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gKlxuICogQGNhbGxiYWNrIFJlcGxhY2VGdW5jdGlvblxuICogICBDYWxsYmFjayBjYWxsZWQgd2hlbiBhIHNlYXJjaCBtYXRjaGVzLlxuICogQHBhcmFtIHsuLi5hbnl9IHBhcmFtZXRlcnNcbiAqICAgVGhlIHBhcmFtZXRlcnMgYXJlIHRoZSByZXN1bHQgb2YgY29ycmVzcG9uZGluZyBzZWFyY2ggZXhwcmVzc2lvbjpcbiAqXG4gKiAgICogYHZhbHVlYCAoYHN0cmluZ2ApIOKAlCB3aG9sZSBtYXRjaFxuICogICAqIGAuLi5jYXB0dXJlYCAoYEFycmF5PHN0cmluZz5gKSDigJQgbWF0Y2hlcyBmcm9tIHJlZ2V4IGNhcHR1cmUgZ3JvdXBzXG4gKiAgICogYG1hdGNoYCAoYFJlZ0V4cE1hdGNoT2JqZWN0YCkg4oCUIGluZm8gb24gdGhlIG1hdGNoXG4gKiBAcmV0dXJucyB7QXJyYXk8UGhyYXNpbmdDb250ZW50PiB8IFBocmFzaW5nQ29udGVudCB8IHN0cmluZyB8IGZhbHNlIHwgdW5kZWZpbmVkIHwgbnVsbH1cbiAqICAgVGhpbmcgdG8gcmVwbGFjZSB3aXRoLlxuICpcbiAqICAgKiB3aGVuIGBudWxsYCwgYHVuZGVmaW5lZGAsIGAnJ2AsIHJlbW92ZSB0aGUgbWF0Y2hcbiAqICAgKiDigKZvciB3aGVuIGBmYWxzZWAsIGRvIG5vdCByZXBsYWNlIGF0IGFsbFxuICogICAqIOKApm9yIHdoZW4gYHN0cmluZ2AsIHJlcGxhY2Ugd2l0aCBhIHRleHQgbm9kZSBvZiB0aGF0IHZhbHVlXG4gKiAgICog4oCmb3Igd2hlbiBgTm9kZWAgb3IgYEFycmF5PE5vZGU+YCwgcmVwbGFjZSB3aXRoIHRob3NlIG5vZGVzXG4gKlxuICogQHR5cGVkZWYge3N0cmluZyB8IFJlZ0V4cH0gRmluZFxuICogICBQYXR0ZXJuIHRvIGZpbmQuXG4gKlxuICogICBTdHJpbmdzIGFyZSBlc2NhcGVkIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGdsb2JhbCBleHByZXNzaW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7QXJyYXk8RmluZEFuZFJlcGxhY2VUdXBsZT59IEZpbmRBbmRSZXBsYWNlTGlzdFxuICogICBTZXZlcmFsIGZpbmQgYW5kIHJlcGxhY2VzLCBpbiBhcnJheSBmb3JtLlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIFJlcGxhY2U+fSBGaW5kQW5kUmVwbGFjZVNjaGVtYVxuICogICBTZXZlcmFsIGZpbmQgYW5kIHJlcGxhY2VzLCBpbiBvYmplY3QgZm9ybS5cbiAqIEB0eXBlZGVmIHtbRmluZCwgUmVwbGFjZV19IEZpbmRBbmRSZXBsYWNlVHVwbGVcbiAqICAgRmluZCBhbmQgcmVwbGFjZSBpbiB0dXBsZSBmb3JtLlxuICogQHR5cGVkZWYge3N0cmluZyB8IFJlcGxhY2VGdW5jdGlvbn0gUmVwbGFjZVxuICogICBUaGluZyB0byByZXBsYWNlIHdpdGguXG4gKiBAdHlwZWRlZiB7W1JlZ0V4cCwgUmVwbGFjZUZ1bmN0aW9uXX0gUGFpclxuICogICBOb3JtYWxpemVkIGZpbmQgYW5kIHJlcGxhY2UuXG4gKiBAdHlwZWRlZiB7QXJyYXk8UGFpcj59IFBhaXJzXG4gKiAgIEFsbCBmaW5kIGFuZCByZXBsYWNlZC5cbiAqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge1Rlc3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbaWdub3JlXVxuICogICBUZXN0IGZvciB3aGljaCBub2RlcyB0byBpZ25vcmUuXG4gKi9cblxuaW1wb3J0IGVzY2FwZSBmcm9tICdlc2NhcGUtc3RyaW5nLXJlZ2V4cCdcbmltcG9ydCB7dmlzaXRQYXJlbnRzfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnXG5pbXBvcnQge2NvbnZlcnR9IGZyb20gJ3VuaXN0LXV0aWwtaXMnXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKlxuICogRmluZCBwYXR0ZXJucyBpbiBhIHRyZWUgYW5kIHJlcGxhY2UgdGhlbS5cbiAqXG4gKiBUaGUgYWxnb3JpdGhtIHNlYXJjaGVzIHRoZSB0cmVlIGluICpwcmVvcmRlciogZm9yIGNvbXBsZXRlIHZhbHVlcyBpbiBgVGV4dGBcbiAqIG5vZGVzLlxuICogUGFydGlhbCBtYXRjaGVzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB0cmVlXG4gKiAgIFRyZWUgdG8gY2hhbmdlLlxuICogQHBhcmFtIGZpbmRcbiAqICAgUGF0dGVybnMgdG8gZmluZC5cbiAqIEBwYXJhbSByZXBsYWNlXG4gKiAgIFRoaW5ncyB0byByZXBsYWNlIHdpdGggKHdoZW4gYGZpbmRgIGlzIGBGaW5kYCkgb3IgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gKHdoZW4gYGZpbmRgIGlzIG5vdCBgRmluZGApLlxuICogQHJldHVybnNcbiAqICAgR2l2ZW4sIG1vZGlmaWVkLCB0cmVlLlxuICovXG4vLyBUbyBkbzogbmV4dCBtYWpvcjogcmVtb3ZlIGBmaW5kYCAmIGByZXBsYWNlYCBjb21ibywgcmVtb3ZlIHNjaGVtYS5cbmV4cG9ydCBjb25zdCBmaW5kQW5kUmVwbGFjZSA9XG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8VHJlZSBleHRlbmRzIE5vZGU+KHRyZWU6IFRyZWUsIGZpbmQ6IEZpbmQsIHJlcGxhY2U/OiBSZXBsYWNlIHwgbnVsbCB8IHVuZGVmaW5lZCwgb3B0aW9ucz86IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBUcmVlKSAmXG4gICAqICAgKDxUcmVlIGV4dGVuZHMgTm9kZT4odHJlZTogVHJlZSwgc2NoZW1hOiBGaW5kQW5kUmVwbGFjZVNjaGVtYSB8IEZpbmRBbmRSZXBsYWNlTGlzdCwgb3B0aW9ucz86IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBUcmVlKVxuICAgKiApfVxuICAgKiovXG4gIChcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUge05vZGV9IFRyZWVcbiAgICAgKiBAcGFyYW0ge1RyZWV9IHRyZWVcbiAgICAgKiBAcGFyYW0ge0ZpbmQgfCBGaW5kQW5kUmVwbGFjZVNjaGVtYSB8IEZpbmRBbmRSZXBsYWNlTGlzdH0gZmluZFxuICAgICAqIEBwYXJhbSB7UmVwbGFjZSB8IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbcmVwbGFjZV1cbiAgICAgKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJucyB7VHJlZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodHJlZSwgZmluZCwgcmVwbGFjZSwgb3B0aW9ucykge1xuICAgICAgLyoqIEB0eXBlIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBzZXR0aW5nc1xuICAgICAgLyoqIEB0eXBlIHtGaW5kQW5kUmVwbGFjZVNjaGVtYXxGaW5kQW5kUmVwbGFjZUxpc3R9ICovXG4gICAgICBsZXQgc2NoZW1hXG5cbiAgICAgIGlmICh0eXBlb2YgZmluZCA9PT0gJ3N0cmluZycgfHwgZmluZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGRvbuKAmXQgZXhwZWN0IG9wdGlvbnMgdHdpY2UuXG4gICAgICAgIHNjaGVtYSA9IFtbZmluZCwgcmVwbGFjZV1dXG4gICAgICAgIHNldHRpbmdzID0gb3B0aW9uc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hID0gZmluZFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGRvbuKAmXQgZXhwZWN0IHJlcGxhY2UgdHdpY2UuXG4gICAgICAgIHNldHRpbmdzID0gcmVwbGFjZVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzID0ge31cbiAgICAgIH1cblxuICAgICAgY29uc3QgaWdub3JlZCA9IGNvbnZlcnQoc2V0dGluZ3MuaWdub3JlIHx8IFtdKVxuICAgICAgY29uc3QgcGFpcnMgPSB0b1BhaXJzKHNjaGVtYSlcbiAgICAgIGxldCBwYWlySW5kZXggPSAtMVxuXG4gICAgICB3aGlsZSAoKytwYWlySW5kZXggPCBwYWlycy5sZW5ndGgpIHtcbiAgICAgICAgdmlzaXRQYXJlbnRzKHRyZWUsICd0ZXh0JywgdmlzaXRvcilcbiAgICAgIH1cblxuICAgICAgLy8gVG8gZG8gbmV4dCBtYWpvcjogZG9u4oCZdCByZXR1cm4gdGhlIGdpdmVuIHRyZWUuXG4gICAgICByZXR1cm4gdHJlZVxuXG4gICAgICAvKiogQHR5cGUge2ltcG9ydCgndW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzL2NvbXBsZXgtdHlwZXMuanMnKS5CdWlsZFZpc2l0b3I8Um9vdCwgJ3RleHQnPn0gKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0b3Iobm9kZSwgcGFyZW50cykge1xuICAgICAgICBsZXQgaW5kZXggPSAtMVxuICAgICAgICAvKiogQHR5cGUge1BhcmVudCB8IHVuZGVmaW5lZH0gKi9cbiAgICAgICAgbGV0IGdyYW5kcGFyZW50XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBwYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudHNbaW5kZXhdXG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpZ25vcmVkKFxuICAgICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFRTIGRvZXNu4oCZdCB1bmRlcnN0YW5kIGJ1dCBpdOKAmXMgcGVyZmVjdC5cbiAgICAgICAgICAgICAgZ3JhbmRwYXJlbnQgPyBncmFuZHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHBhcmVudCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGdyYW5kcGFyZW50XG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBncmFuZHBhcmVudCA9IHBhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyYW5kcGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXIobm9kZSwgcGFyZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBhIHRleHQgbm9kZSB3aGljaCBpcyBub3QgaW4gYW4gaWdub3JlZCBwYXJlbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtUZXh0fSBub2RlXG4gICAgICAgKiAgIFRleHQgbm9kZS5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXk8UGFyZW50Pn0gcGFyZW50c1xuICAgICAgICogICBQYXJlbnRzLlxuICAgICAgICogQHJldHVybnMge1Zpc2l0b3JSZXN1bHR9XG4gICAgICAgKiAgIFJlc3VsdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gaGFuZGxlcihub2RlLCBwYXJlbnRzKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXVxuICAgICAgICBjb25zdCBmaW5kID0gcGFpcnNbcGFpckluZGV4XVswXVxuICAgICAgICBjb25zdCByZXBsYWNlID0gcGFpcnNbcGFpckluZGV4XVsxXVxuICAgICAgICBsZXQgc3RhcnQgPSAwXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFRTIGlzIHdyb25nLCBzb21lIG9mIHRoZXNlIGNoaWxkcmVuIGNhbiBiZSB0ZXh0LlxuICAgICAgICBjb25zdCBpbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKG5vZGUpXG4gICAgICAgIGxldCBjaGFuZ2UgPSBmYWxzZVxuICAgICAgICAvKiogQHR5cGUge0FycmF5PFBocmFzaW5nQ29udGVudD59ICovXG4gICAgICAgIGxldCBub2RlcyA9IFtdXG5cbiAgICAgICAgZmluZC5sYXN0SW5kZXggPSAwXG5cbiAgICAgICAgbGV0IG1hdGNoID0gZmluZC5leGVjKG5vZGUudmFsdWUpXG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBtYXRjaC5pbmRleFxuICAgICAgICAgIC8qKiBAdHlwZSB7UmVnRXhwTWF0Y2hPYmplY3R9ICovXG4gICAgICAgICAgY29uc3QgbWF0Y2hPYmplY3QgPSB7XG4gICAgICAgICAgICBpbmRleDogbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICBpbnB1dDogbWF0Y2guaW5wdXQsXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzdGFjayBpcyBmaW5lLlxuICAgICAgICAgICAgc3RhY2s6IFsuLi5wYXJlbnRzLCBub2RlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdmFsdWUgPSByZXBsYWNlKC4uLm1hdGNoLCBtYXRjaE9iamVjdClcblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmxlbmd0aCA+IDAgPyB7dHlwZTogJ3RleHQnLCB2YWx1ZX0gOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJdCB3YXNu4oCZdCBhIG1hdGNoIGFmdGVyIGFsbC5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgIT09IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZS5zbGljZShzdGFydCwgcG9zaXRpb24pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKC4uLnZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGFydCA9IHBvc2l0aW9uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmaW5kLmdsb2JhbCkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRjaCA9IGZpbmQuZXhlYyhub2RlLnZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICAgIGlmIChzdGFydCA8IG5vZGUudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHt0eXBlOiAndGV4dCcsIHZhbHVlOiBub2RlLnZhbHVlLnNsaWNlKHN0YXJ0KX0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSwgLi4ubm9kZXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZXMgPSBbbm9kZV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleCArIG5vZGVzLmxlbmd0aFxuICAgICAgfVxuICAgIH1cbiAgKVxuXG4vKipcbiAqIFR1cm4gYSBzY2hlbWEgaW50byBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0ZpbmRBbmRSZXBsYWNlU2NoZW1hIHwgRmluZEFuZFJlcGxhY2VMaXN0fSBzY2hlbWFcbiAqICAgU2NoZW1hLlxuICogQHJldHVybnMge1BhaXJzfVxuICogICBDbGVhbiBwYWlycy5cbiAqL1xuZnVuY3Rpb24gdG9QYWlycyhzY2hlbWEpIHtcbiAgLyoqIEB0eXBlIHtQYWlyc30gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhcnJheSBvciBvYmplY3QgYXMgc2NoZW1hJylcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBzY2hlbWEubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChbXG4gICAgICAgIHRvRXhwcmVzc2lvbihzY2hlbWFbaW5kZXhdWzBdKSxcbiAgICAgICAgdG9GdW5jdGlvbihzY2hlbWFbaW5kZXhdWzFdKVxuICAgICAgXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IGtleVxuXG4gICAgZm9yIChrZXkgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAob3duLmNhbGwoc2NoZW1hLCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFt0b0V4cHJlc3Npb24oa2V5KSwgdG9GdW5jdGlvbihzY2hlbWFba2V5XSldKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBUdXJuIGEgZmluZCBpbnRvIGFuIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtGaW5kfSBmaW5kXG4gKiAgIEZpbmQuXG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICogICBFeHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiB0b0V4cHJlc3Npb24oZmluZCkge1xuICByZXR1cm4gdHlwZW9mIGZpbmQgPT09ICdzdHJpbmcnID8gbmV3IFJlZ0V4cChlc2NhcGUoZmluZCksICdnJykgOiBmaW5kXG59XG5cbi8qKlxuICogVHVybiBhIHJlcGxhY2UgaW50byBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVwbGFjZX0gcmVwbGFjZVxuICogICBSZXBsYWNlLlxuICogQHJldHVybnMge1JlcGxhY2VGdW5jdGlvbn1cbiAqICAgRnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRvRnVuY3Rpb24ocmVwbGFjZSkge1xuICByZXR1cm4gdHlwZW9mIHJlcGxhY2UgPT09ICdmdW5jdGlvbicgPyByZXBsYWNlIDogKCkgPT4gcmVwbGFjZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdast-util-find-and-replace/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ escapeStringRegexp)\n/* harmony export */ });\nfunction escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL25vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYWRlbmNlLWNvb2tib29rLy4vbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZmluZC1hbmQtcmVwbGFjZS9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanM/Y2EwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyaW5nKSB7XG5cdGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHQvLyBFc2NhcGUgY2hhcmFjdGVycyB3aXRoIHNwZWNpYWwgbWVhbmluZyBlaXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgY2hhcmFjdGVyIHNldHMuXG5cdC8vIFVzZSBhIHNpbXBsZSBiYWNrc2xhc2ggZXNjYXBlIHdoZW4gaXTigJlzIGFsd2F5cyB2YWxpZCwgYW5kIGEgYFxceG5uYCBlc2NhcGUgd2hlbiB0aGUgc2ltcGxlciBmb3JtIHdvdWxkIGJlIGRpc2FsbG93ZWQgYnkgVW5pY29kZSBwYXR0ZXJuc+KAmSBzdHJpY3RlciBncmFtbWFyLlxuXHRyZXR1cm4gc3RyaW5nXG5cdFx0LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nLCAnXFxcXCQmJylcblx0XHQucmVwbGFjZSgvLS9nLCAnXFxcXHgyZCcpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js\n");

/***/ })

};
;